//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18444
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;

using NSWorldState;
using NSAgent;
using NSActionAbstract;
using NSPlan;
using NSCSharpPlanner;

namespace NSGoalAbstract
{
    // enums should be moved to a seperate enums namespace for all?
    public enum ENUM_AI_CONTEXT
    {
        kContext_Invalid = -1,
        kContext_Advancing,
        kContext_Goto,
        kContext_Investigating,
        kContext_None,
        kContext_Retreating,
        kContext_Searching,
    };

    public enum ENUM_GOAL_TYPE
    {
        kGoal_InvalidType = -1,
        kGoal_Cover,
        kGoal_Dodge,
        kGoal_Idle,
        kGoal_Investigate,
        kGoal_Flee,
        kGoal_Follow,
        kGoal_Guard,
        kGoal_NeutraliseSuspect,
        kGoal_Search,
        kGoal_UseWorldObject,

        //Count always last
        kGoal_Count,

    };
	// this should probably be turned into a c# abstract class.
	public abstract class GoalAbstract
	{
		
        public string[] s_GoalTypes = 
		{
			"kGoal_Cover", 
			"kGoal_Dodge", 
			"kGoal_Idle",
			"kGoal_Investigate",
			"kGoal_Flee",
			"kGoal_Follow",
			"kGoal_Guard",
			"kGoal_NeutraliseSuspect",
			"kGoal_Search",
			"kGoal_UseWorldObject",
		};
	
		protected Agent				m_Agent; //backpointer equiv
		protected ENUM_GOAL_TYPE	m_eGoalType;
		protected float				m_fGoalRelevance;
		protected double 			m_fNextRecalcTime;
		protected double			m_fActivationTime;
		protected ENUM_AI_CONTEXT	m_eAIContext;
		protected float 			m_fRecalcRate;
		protected float				m_fActivateChance;
		protected float				m_fInterruptPriority;
		protected float 			m_fFrequency;

		protected bool				m_bCanReactivateDuringTransitions;
		protected bool 				m_bReEvalOnSatisfied;

		//This function is private as it should not be used by derived classes
		//to get thecontext were use GetGontext() which does some additional validation/reporting
        private ENUM_AI_CONTEXT OnGetContext()
        {
            return m_eAIContext;
        }

		public GoalAbstract()
		{
			m_Agent 			= null;
			m_eGoalType 		= ENUM_GOAL_TYPE.kGoal_InvalidType;
			m_fGoalRelevance 	= 0.0f;
			m_fNextRecalcTime 	= 0.0f;
			m_fActivationTime	= 0.0f;

			m_eAIContext		= ENUM_AI_CONTEXT.kContext_Invalid;
			m_fRecalcRate		= 0.0f;
			m_fActivateChance	= 0.0f;
			m_fInterruptPriority = 0.0f;
			m_fFrequency			= 0.0f;
			m_bCanReactivateDuringTransitions = false;
			m_bReEvalOnSatisfied = false;


		}

		public string GetGoalTypeName(ENUM_GOAL_TYPE eGoalType)
		{
            if (eGoalType < 0 || eGoalType >= ENUM_GOAL_TYPE.kGoal_Count)
			{
				return "";
			}

            return s_GoalTypes[(int)eGoalType];
		}

		public ENUM_GOAL_TYPE GetGoalType(string sGoalTypeName)
		{
			if(sGoalTypeName == null)
			{
				return ENUM_GOAL_TYPE.kGoal_InvalidType;
			}

			for (int i = 0; i < (int)ENUM_GOAL_TYPE.kGoal_Count; ++i)
			{
				//string compare func
				if (sGoalTypeName.Equals(s_GoalTypes[i],StringComparison.Ordinal))
				{
					return (ENUM_GOAL_TYPE)i; // cast to enum
				}

			}

			return ENUM_GOAL_TYPE.kGoal_InvalidType;

		}
	

		public virtual void InitGoal(Agent agent, ENUM_GOAL_TYPE eGoalType)
		{
			m_Agent = agent;
			m_eGoalType = eGoalType;

			if(m_fRecalcRate > 0.0f)
			{
				SetNextRecalcTime();
			}

			//Sensor Setup goes here.
		}
		
		public void TerminateGoal()
		{
			//some thing here? - not forced to subclass?
		} 

		public abstract void 	CalculateGoalRelevance();
		public float 			GetGoalRelevance() { return m_fGoalRelevance; }
		public void 			ClearGoalRelevance() { m_fGoalRelevance = 0.0f; }
		public virtual void 	HandleBuildPlanFailure() { ClearGoalRelevance(); }
		public bool 			GetReEvalOnSatisfied() { return m_bReEvalOnSatisfied; }

		public virtual float 	GetActivationChance() { return m_fActivateChance; }
		public virtual bool 	GetCanReactivateDuringTransitions() { return m_bCanReactivateDuringTransitions; }
		public virtual float 	GetInterruptPriority() { return m_fInterruptPriority; }
		public float 			GetFrequenct() { return m_fFrequency; }
		public float			GetRecalcRate() { return m_fRecalcRate; }

		public virtual double	GetNextRecalcTime() { return m_fNextRecalcTime; }
		public virtual void 	SetNextRecalcTime()
		{
			if(m_fRecalcRate > 0.0f) 
			{
				//c# version of timegettime()
				m_fNextRecalcTime = (DateTime.UtcNow.Millisecond/1000) + m_fRecalcRate;
			}

		}

		public virtual void ActivateGoal()
		{
			m_fActivationTime = DateTime.UtcNow.Second; // maybe better than above?

			// Don't allow two goals to use the same path.  Always recalculate, even if the destination is the same.
			m_Agent.GetBlackBoard().SetBBInvalidatePath(true);

		}

		public virtual void DeactivateGoal()
		{
			if(m_fFrequency > 0.0f)
			{
				m_fNextRecalcTime = DateTime.UtcNow.Millisecond/1000;
			}
		}

		//check if a plan step is completed- then move to next one
		public virtual bool UpdateGoal()
		{
			Plan m_Plan = m_Agent.GetPlan();
			
			if( m_Plan == null )
			{
				return false;
			}
			
			if( m_Plan.IsPlanStepComplete() )
			{
				return m_Plan.AdvancePlan();
			}
			
			return true;
		}

		//was WorldState& in c++
		public virtual void SetWSSatisfaction(ref WorldState worldstate)
		{
			//something
		}

		public virtual bool IsWSSatisfied(WorldState worldstate) { return false; }

		public virtual void UpdateTaskStatus() 
		{
			//something
		}

		public virtual bool ReplanRequired() { return false; }

		public bool	BuildPlan()
		{
			return m_Agent.GetGoalPlanner().BuildPlan(this);
		}

		public void	SetPlan(Plan plan)
		{
			if (plan == null)
			{
				return;
			}

			m_Agent.SetPlan(plan);

		}

		public void ActivatePlan()
		{
			Plan plan = m_Agent.GetPlan();

			if(plan != null)
			{
				plan.ActivatePlan(m_Agent);
			}

		}

		public virtual bool IsPlanValid()
		{
			Plan plan = m_Agent.GetPlan();

			if(plan != null)
			{
				return false;
			}

			return plan.IsPlanValid();

		}

		public void ClearPlan()
		{
			m_Agent.SetPlan(null);
		}

		public bool IsPlanInterruptable()
		{
			Plan plan = m_Agent.GetPlan();
			
			if(plan != null)
			{
				return plan.IsPlanStepInterruptible();
			}
			
			return true;

		}

		public ActionAbstract GetCurrentAction()
		{
			Plan plan = m_Agent.GetPlan();
			
			if(plan != null)
			{
				return plan.GetCurrentPlanStepAction();
			}
			
			return null;

		}


		//returns the ENUM_AI_CONTEXT associated with this goal
		//this is guaranteed to be a valid contect or kContext_Invalid
		//it is only valid to call this function on active goals
		public ENUM_AI_CONTEXT	GetContext()
		{
			//BKJ:Tofix
			// Verify the goal is currently active.
			if( !m_Agent.GetGoalStorage().IsCurrentGoal(this) )
			{
                Console.WriteLine("GoalAbstract::GetContext: This function is only valid while a goal is active.");
			}
			
			ENUM_AI_CONTEXT eContext = OnGetContext();
			
			// Verify the context to be returned is valid.
            if (eContext == ENUM_AI_CONTEXT.kContext_Invalid)
			{
                Console.WriteLine("GoalAbstract::GetContext: out of range ID for goal: {0}", GetGoalTypeName(GetGoalType()));
                return ENUM_AI_CONTEXT.kContext_Invalid;
			}
			
			return eContext;

		}

		public bool IsPermanentGoal() { return false; }
		
		public ENUM_GOAL_TYPE GetGoalType() { return m_eGoalType; }

	}
}

